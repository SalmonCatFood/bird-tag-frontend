# é¡¹ç›®è®¡åˆ’

## åŸºç¡€èµ„æº



### S3:


- å›¾åƒåŸå›¾ï¼š`IMAGES_S3`
- å›¾åƒç¼©ç•¥å›¾ï¼š`THUMBNAILS_S3`
- éŸ³é¢‘åŸå§‹ï¼š`AUDIO_S3`
- è§†é¢‘åŸå§‹ï¼š`VIDEO_S3`

### DynamoDB
METADATA_TABLE:

```plain
file_id:          S   # ä¸»é”®
user_id
s3_url:           S
thumbnail_url:    S   # ä»…å›¾åƒæˆ–è§†é¢‘é¦–å¸§æˆªå›¾
file_type:        S   # "image"ã€"audio" æˆ– "video"
tags:             M   # Map<String, Number or String>
upload_timestamp: S   # ISO 8601 æ ¼å¼
additional_metadata: M # å¯é€‰ï¼ˆéŸ³é¢‘åˆ†æ®µã€è§†é¢‘å¸§æ—¶é—´ç‰‡æ®µç­‰ï¼‰
```



CONNECTION_TABLE

```plain
connection_id: S ä¸»é”®
user_id: S,è¡¨æ˜ WebSocket è¿æ¥å±äºå“ªä¸ªç”¨æˆ·ã€‚
connected_at:S , ISOæ—¶é—´æˆ³ ,è®°å½•è¿æ¥é¦–æ¬¡å»ºç«‹çš„æ—¶é—´
last_seen:S, ISOæ—¶é—´æˆ³ ,è¡¨ç¤ºè¯¥è¿æ¥çš„æœ€è¿‘æ´»è·ƒæ—¶é—´
```



## å®Œæ•´æ•°æ® /æ¶ˆæ¯æµ
1. **ç”¨æˆ·ç™»å½• / å‰ç«¯æŒæœ‰ Token**  
ç”¨æˆ·é€šè¿‡ Cognito ç™»å½• /ä¸€é”®ç™»å½•ï¼Œå‰ç«¯è·å¾— JWTï¼Œå…¶ä¸­åŒ…å« `user_id`ï¼ˆæˆ– `sub`ï¼‰ç­‰èº«ä»½æ ‡è¯†ã€‚
2. **å‰ç«¯å‘èµ·ä¸Šä¼ è¯·æ±‚**  
å‰ç«¯å‘ä½ çš„ REST API å‘ `POST /upload-file`ï¼Œè¯·æ±‚ä½“ä¾‹å¦‚ï¼š

```plain
{
  "token": "<JWT>",
  "filename": "example.jpg",
  "content_type": "image/jpeg"
}
```

3. **upload-file Lambda éªŒè¯ token + å†™ metadata + ç”Ÿæˆ presign URL**  
- Lambda ä»è¯·æ±‚ä½“ä¸­å–å‡º `token`ï¼Œå¯¹ JWT è§£ç ã€éªŒç­¾ã€æ£€æŸ¥è¿‡æœŸ /issuer /audience ç­‰  
- è‹¥éªŒè¯å¤±è´¥ï¼Œåˆ™è¿”å› HTTP 401 /é”™è¯¯å“åº”  
- è‹¥éªŒè¯æˆåŠŸï¼Œä» JWT payload è·å– `user_id`  
- ç”Ÿæˆä¸€ä¸ªå”¯ä¸€ `file_id`  
- æ ¹æ® `file_type`ï¼ˆç”± `content_type` æ´¾ç”Ÿï¼š`image` / `video` / `audio`ï¼‰ï¼Œç¡®å®šè¦å†™å…¥å“ªä¸ªæ¡¶ä¸è·¯å¾„å‰ç¼€  
* è‹¥ file_type = `image` â†’ S3 åŸå›¾æ¡¶ç”¨è·¯å¾„ `image/â€¦`  
* è‹¥ file_type = `video` â†’ è§†é¢‘æ¡¶ç”¨è·¯å¾„ `video/â€¦`  
* è‹¥ file_type = `audio` â†’ éŸ³é¢‘æ¡¶è·¯å¾„ `audio/â€¦`  
- æ„é€  S3 keyï¼Œä¾‹å¦‚ `<prefix>/<user_id>_<file_id>.<ext>`ï¼ˆå¦‚ `image/user42_abcd1234.jpg`ï¼‰  
- åœ¨ METADATA_TABLE æ’å…¥åˆå§‹æ¡ç›®ï¼Œå­—æ®µå¦‚ï¼š

```plain
{
  "file_id": "...",
  "user_id": "...",
  "s3_url": null,           // æˆ–è€…å­˜ key æˆ–å­˜æ§ä»¶ URLï¼Œä½ å¯ä»¥åç»­å†™å®Œæ•´ URL
  "thumbnail_url": null,
  "file_type": "image",
  "tags": {},
  "upload_timestamp": now(),
  "additional_metadata": {}
}
```

- ç”Ÿæˆ presigned PUT URLï¼ŒæŒ‡å‘æ¡¶ + keyï¼ˆä¾‹å¦‚ `https://IMAGES_S3.s3.region.amazonaws.com/image/user42_abcd1234.jpg?signature=...`ï¼‰  
- è¿”å›ç»™å‰ç«¯ï¼š

```plain
{
  "file_id": "...",
  "presign_url": "<the presigned URL>",
  "s3_key": "image/user42_abcd1234.jpg"
}
```

4. **å‰ç«¯ä¸Šä¼ æ–‡ä»¶ + å»ºç«‹ WebSocket è¿æ¥**  
- å‰ç«¯ä½¿ç”¨è¿”å›çš„ `presign_url` å°†æ–‡ä»¶æ•°æ®ä¸Šä¼ åˆ°ç›®æ ‡ S3 æ¡¶ + key  
- åŒæ—¶å‰ç«¯å»ºç«‹ WebSocket è¿æ¥ç»™ WebSocket APIï¼ŒURL å¯èƒ½æ˜¯ï¼š

```plain
wss://{websocket-api-id}.execute-api.{region}.amazonaws.com/{stage}?token=<JWT>&file_id=<file_id>
```

5. **API Gateway WebSocket æ¥æ”¶æ¡æ‰‹ â†’ è°ƒç”¨ Lambda Authorizerï¼ˆåœ¨ $connectï¼‰**  
- WebSocket æ¡æ‰‹åˆ°è¾¾ API Gatewayï¼ˆè·¯ç”± `$connect`ï¼‰  
- å› ä½ åœ¨ `$connect` è·¯ç”±ä¸Šé…ç½®äº† Lambda Authorizerï¼ŒAPI Gateway é¦–å…ˆè°ƒç”¨è¯¥ Authorizer å‡½æ•°  
- Authorizer æ¥æ”¶åˆ°äº‹ä»¶ `event`ï¼Œå…¶ä¸­åŒ…å« `queryStringParameters.token`ã€`requestContext.connectionId`ã€`methodArn`ã€`routeKey="$connect"` ç­‰  
- Authorizer éªŒè¯ tokenï¼ˆéªŒç­¾ /è¿‡æœŸ /issuer /audience ç­‰ï¼‰  
* å¦‚æœéªŒè¯å¤±è´¥ â†’ è¿”å› Deny â†’ API Gateway æ‹’ç»å»ºç«‹è¿æ¥  
* å¦‚æœéªŒè¯æˆåŠŸ â†’ è¿”å› Allow ç­–ç•¥ + åœ¨è¿”å›çš„ `context` ä¸­æ³¨å…¥ `user_id`
6. **API Gateway è‹¥æˆæƒé€šè¿‡ â†’ è°ƒç”¨ ConnectHandler Lambda**  
- ConnectHandler çš„ `event.requestContext.authorizer.user_id` æœ‰æ³¨å…¥çš„ `user_id`  
- ConnectHandler çš„ `event.requestContext.connectionId` æ˜¯è¯¥è¿æ¥çš„ connection_id  
- ConnectHandler å‘ CONNECTION_TABLE å†™å…¥ä¸€æ¡è®°å½•ï¼š

```plain
{
  connection_id: <connection_id>,
  user_id: <user_id>,
  connected_at: now(),
  last_seen: now()
}
```

- ConnectHandler è¿”å›æˆåŠŸå“åº”ï¼ˆ200 OKï¼‰ï¼ŒWebSocket è¿æ¥å»ºç«‹å®Œæ¯•

7. **S3 ä¸Šä¼ æˆåŠŸè§¦å‘å¤„ç†ï¼ˆImage / Video åˆ†æ”¯ï¼‰**  
- å®¢æˆ·ç«¯ä¸Šä¼ çš„å¯¹è±¡è½åœ¨å¯¹åº”æ¡¶ + keyï¼ˆä¾‹å¦‚ `IMAGES_S3`ä¸‹ `image/...` æˆ– `VIDEO_S3`ä¸‹ `video/...`ï¼‰  
- S3 è§¦å‘ EventBridge æˆ– S3 äº‹ä»¶é€šçŸ¥  
- æ ¹æ®è·¯å¾„ /æ¡¶åˆ¤æ–­è§¦å‘å“ªä¸ª Lambdaï¼š  
* **ThumbnailLambda**ï¼šæ— è®ºæ˜¯ image è¿˜æ˜¯ video ä¸Šä¼ ï¼Œéƒ½è¢«è§¦å‘ã€‚ThumbnailLambda è¯»å–åŸå¯¹è±¡ â†’ ç”Ÿæˆç¼©ç•¥å›¾ â†’ ä¸Šä¼ è‡³ THUMBNAILS_S3ï¼Œç”¨è·¯å¾„å‰ç¼€ `thumbnail/...`ï¼ˆå¦‚ `thumbnail/user42_abcd1234.jpg`ï¼‰ï¼Œå¾—åˆ° `thumbnail_url`  
* å¦‚æœ file_type = `image` â†’ åŒæ—¶è§¦å‘ **Image_tagging_lambda**ï¼Œå¯¹å›¾åƒåšè¯†åˆ« /æ¨ç† â†’ å¾—åˆ° `tags`  
* å¦‚æœ file_type = `video` â†’ åŒæ—¶è§¦å‘ **Video_tagging_lambda**ï¼Œå¯¹è§†é¢‘åšè¯†åˆ« /å¸§åˆ†æç­‰ â†’ å¾—åˆ° `tags` æˆ–ç›¸å…³ metadata  
* å¦‚æœ file_type = `audio` â†’ ï¼ˆå¯èƒ½æ²¡æœ‰ thumbnailï¼‰è§¦å‘ `Audio_tagging_lambda` æˆ–ç›¸åº”å¤„ç† Lambda
8. **ThumbnailLambda æ›´æ–° METADATA_TABLE**  
- ç¼©ç•¥å›¾å®Œæˆåï¼ŒThumbnailLambda æ›´æ–° METADATA_TABLE ä¸­è¯¥ `file_id` æ¡ç›®ï¼Œå†™å…¥ `thumbnail_url` å­—æ®µï¼ˆä¾‹å¦‚æŒ‡å‘ `https://THUMBNAILS_S3.s3.region.amazonaws.com/thumbnail/user42_abcd1234.jpg`ï¼‰  
- æ›´æ–° `upload_timestamp` æˆ–å…¶ä»–å­—æ®µï¼ˆå¦‚åœ¨ `additional_metadata` å†™å¸§æ—¶é—´ç‚¹ç­‰ï¼‰  
- æ­¤å†™æ“ä½œè§¦å‘ DynamoDB Streams ä¸­çš„ `NewImage` è®°å½•
9. **Image_tagging_lambda / Video_tagging_lambda æ›´æ–° METADATA_TABLE**  
- è¯†åˆ« /æ¨ç†å®Œæˆåï¼Œè¿™äº› Lambda æ›´æ–°åŒä¸€æ¡ METADATA_TABLE è®°å½•ï¼Œå†™å…¥ `tags` å­—æ®µ  
- å¯èƒ½æ›´æ–° `additional_metadata`ï¼ˆä¾‹å¦‚è§†é¢‘åˆ†æ®µä¿¡æ¯ã€å¸§æ—¶é—´æˆ³ç­‰ï¼‰  
- æ­¤å†™æ“ä½œä¹Ÿè§¦å‘ DynamoDB Streams çš„ `NewImage` è®°å½•
10. **DynamoDB Streams è§¦å‘ Meta_db_update Lambda**  
- METADATA_TABLE å¯ç”¨äº† Streamsï¼Œä»»ä½•å†™å…¥ /æ›´æ–°éƒ½ä¼šäº§ç”Ÿ `NewImage` è®°å½•  
- Meta_db_update Lambda è¢«è§¦å‘ï¼Œå®ƒä» event ä¸­è¯»å–è¿™ä¸€å˜åŒ–çš„æ–°å€¼ `NewImage`ï¼Œæ‹¿åˆ°å­—æ®µï¼š  
`file_id`, `user_id`, `thumbnail_url`, `tags`, `file_type`, `s3_url`, `upload_timestamp` ç­‰
11. **Meta_db_update Lambda æŸ¥ CONNECTION_TABLE æ¨é€æ¶ˆæ¯**  
- ä½¿ç”¨ `user_id` æŸ¥è¯¢ CONNECTION_TABLEï¼Œå¾—åˆ°æ­¤ç”¨æˆ·æ´»è·ƒçš„ connection_ids  
- æ„é€ è¦æ¨é€çš„ payloadï¼ˆå¯ä»¥åªå¸¦å˜æ›´å­—æ®µæˆ–å®Œæ•´çŠ¶æ€ï¼‰ï¼Œä¾‹å¦‚ï¼š

```plain
{
  "type": "FILE_UPDATE",
  "file_id": "...",
  "file_type": "...",
  "thumbnail_url": "https://â€¦/thumbnail/â€¦",
  "tags": { â€¦ },
  "upload_timestamp": "..."
}
```

- å¯¹äºæ¯ä¸€ä¸ª `connection_id`ï¼Œè°ƒç”¨ API Gateway ç®¡ç†ç«¯ç‚¹çš„ `PostToConnection(connection_id, payload)` å‘å®¢æˆ·ç«¯æ¨é€æ¶ˆæ¯ã€‚æ ¹æ® AWS æ–‡æ¡£ï¼Œåç«¯å¯ä»¥ä½¿ç”¨ API Gateway æä¾›çš„ `@connections` æ¥å£ã€‚  
- å¦‚æœæŸä¸ªè¿æ¥å·²å¤±æ•ˆï¼ˆPostToConnection è¿”å›é”™è¯¯ï¼Œå¦‚ 410 Goneï¼‰ï¼ŒMeta_db_update Lambda åˆ é™¤ CONNECTION_TABLE ä¸­å¯¹åº”è¿æ¥è®°å½•

12. **å®¢æˆ·ç«¯ WebSocket æ¥æ”¶æ¶ˆæ¯ /æ›´æ–°ç•Œé¢**  
- å®¢æˆ·ç«¯çš„ WebSocket `onmessage` äº‹ä»¶è¢«è§¦å‘ï¼Œæ‹¿åˆ° payload  
- å¦‚æœ `thumbnail_url` æœ‰å€¼ä½† `tags` è¿˜ç©º â†’ å‰ç«¯å±•ç¤ºç¼©ç•¥å›¾  
- å¦‚æœ `tags` å‡ºç° â†’ æ›´æ–°è¯†åˆ«ç»“æœ UI  
- å¦‚æœç”¨æˆ·ç‚¹å‡» â€œåˆ·æ–°â€ æŒ‰é’®æˆ–é¡µé¢é‡æ–°åŠ è½½æ—¶ï¼Œå‰ç«¯å¯ä»¥è°ƒç”¨ REST API `GET /metadata/{file_id}` æ‹‰å–æœ€æ–°è®°å½•ä½œä¸ºè¡¥å¿
13. **è¿æ¥æ–­å¼€ / æ¸…ç†**  
- å¦‚æœå®¢æˆ·ç«¯æ–­å¼€ WebSocketï¼ŒAPI Gateway ä¼šè§¦å‘ `$disconnect` è·¯ç”±ï¼Œè°ƒç”¨ä½ çš„ `DisconnectHandler` Lambda  
- DisconnectHandler ä» `event.requestContext.connectionId` è·å– `connection_id`ï¼Œç„¶ååˆ é™¤ CONNECTION_TABLE ä¸­å¯¹åº”è®°å½•  
- åœ¨ Meta_db_update æ¨é€é˜¶æ®µï¼Œè‹¥å‘ç°æ¨é€å¤±è´¥ /è¿æ¥æ— æ•ˆï¼Œä¹ŸåŒæ—¶åˆ é™¤è¿æ¥è®°å½•

---

## Lambda ä»£ç èŒƒæœ¬

ä»¥ä¸‹ä¸ºæ¯ä¸ªç©ºå‡½æ•°çš„ `app.py` ä»£ç ç¤ºä¾‹ï¼š

### `UploadFileLambda` 

```
import os
import json
import logging
import boto3
import uuid
from datetime import datetime, timezone

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ['METADATA_TABLE'])

def handler(event, context):
    logger.info(f"UploadFileLambda invoked with event: {json.dumps(event)}")

    # ä» JWT token æå– user_idï¼ˆç¤ºä¾‹ï¼Œä¸å«å®Œæ•´éªŒè¯é€»è¾‘ï¼‰
    # å‡è®¾å‰ç«¯æŠŠ token éªŒå­˜åœ¨ API Authorizerï¼Œä¸­é—´æ‹¿åˆ° user_id
    # è¿™é‡Œä»…æ¨¡æ‹Ÿç”Ÿæˆ file_id å’Œè¿”å› presign URL
    user_id = event.get('requestContext', {}).get('authorizer', {}).get('user_id', 'unknown_user')

    # å‡è®¾ä» body ä¸­è·å– filename å’Œ content_type
    body = json.loads(event.get('body','{}'))
    filename = body.get('filename')
    content_type = body.get('content_type')

    file_id = str(uuid.uuid4())
    now_iso = datetime.now(timezone.utc).isoformat()

    # æ¨æ–­ file_type
    if content_type.startswith('image/'):
        file_type = 'image'
    elif content_type.startswith('video/'):
        file_type = 'video'
    elif content_type.startswith('audio/'):
        file_type = 'audio'
    else:
        file_type = 'unknown'

    # æ„é€  S3 keyï¼ˆç¤ºä¾‹ï¼‰
    key = f"{file_type}/{user_id}_{file_id}.{filename.split('.')[-1]}"

    # æ’å…¥åˆå§‹ metadata
    table.put_item(Item={
        'file_id': file_id,
        'user_id': user_id,
        's3_url': None,
        'thumbnail_url': None,
        'file_type': file_type,
        'tags': {},
        'upload_timestamp': now_iso,
        'additional_metadata': {}
    })

    # ç”Ÿæˆ presigned URLï¼ˆä¸¾ä¾‹ç”¨ s3 clientï¼‰
    s3 = boto3.client('s3')
    bucket = os.environ.get('IMAGES_S3') if file_type=='image' else \
             os.environ.get('VIDEO_S3') if file_type=='video' else \
             os.environ.get('AUDIO_S3') if file_type=='audio' else None

    if bucket:
        presign_url = s3.generate_presigned_url(
            'put_object',
            Params={'Bucket': bucket, 'Key': key, 'ContentType': content_type},
            ExpiresIn=3600
        )
    else:
        presign_url = None

    response = {
        'file_id': file_id,
        'presign_url': presign_url,
        's3_key': key
    }

    return {
        'statusCode': 200,
        'body': json.dumps(response)
    }
```

### `ConnectHandlerLambda` 

```
import os
import json
import logging
import boto3
from datetime import datetime, timezone

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ['CONNECTION_TABLE'])

def handler(event, context):
    logger.info(f"ConnectHandler invoked event: {json.dumps(event)}")

    connection_id = event['requestContext']['connectionId']
    user_id = event['requestContext']['authorizer']['user_id']
    now_iso = datetime.now(timezone.utc).isoformat()

    # å†™å…¥è¿æ¥è®°å½•
    table.put_item(Item={
        'connection_id': connection_id,
        'user_id': user_id,
        'connected_at': now_iso,
        'last_seen': now_iso
    })

    return {'statusCode': 200, 'body': 'connected'}
```

### `DisconnectHandlerLambda` 

```
import os
import json
import logging
import boto3

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')
table = dynamodb.Table(os.environ['CONNECTION_TABLE'])

def handler(event, context):
    logger.info(f"DisconnectHandler invoked event: {json.dumps(event)}")

    connection_id = event['requestContext']['connectionId']

    # åˆ é™¤è¿æ¥è®°å½•
    table.delete_item(Key={'connection_id': connection_id})

    return {'statusCode': 200, 'body': 'disconnected'}
```

### `MetaDbUpdateLambda` 

```
import os
import json
import logging
import boto3

logger = logging.getLogger()
logger.setLevel(logging.INFO)

dynamodb = boto3.resource('dynamodb')
connections_table = dynamodb.Table(os.environ['CONNECTION_TABLE'])

# ç”¨äºè°ƒç”¨ API Gateway çš„ PostToConnection
apigw = boto3.client('apigatewaymanagementapi',
    endpoint_url=os.environ.get('WEBSOCKET_ENDPOINT')  # ä½ éœ€æŠŠ endpoint å­˜ä¸ºç¯å¢ƒå˜é‡
)

def handler(event, context):
    logger.info(f"MetaDbUpdateLambda triggered with event: {json.dumps(event)}")

    # éå† DynamoDB Stream records
    for record in event.get('Records', []):
        if record.get('eventName') not in ('INSERT','MODIFY'):
            continue
        new_image = record['dynamodb']['NewImage']
        user_id = new_image['user_id']['S']
        file_id = new_image['file_id']['S']
        thumbnail_url = new_image.get('thumbnail_url', {}).get('S')
        tags = json.loads(new_image.get('tags', {}).get('M', '{}'))
        file_type = new_image['file_type']['S']
        upload_timestamp = new_image['upload_timestamp']['S']

        payload = {
            'type': 'FILE_UPDATE',
            'file_id': file_id,
            'file_type': file_type,
            'thumbnail_url': thumbnail_url,
            'tags': tags,
            'upload_timestamp': upload_timestamp
        }

        # æŸ¥è¯¢è¯¥ user çš„æ‰€æœ‰è¿æ¥
        response = connections_table.query(
            KeyConditionExpression=boto3.dynamodb.conditions.Key('user_id').eq(user_id)
        )
        for item in response.get('Items', []):
            conn_id = item['connection_id']
            try:
                apigw.post_to_connection(ConnectionId=conn_id, Data=json.dumps(payload).encode('utf-8'))
            except apigw.exceptions.GoneException:
                # è¿æ¥ä¸å†æœ‰æ•ˆï¼Œåˆ é™¤
                connections_table.delete_item(Key={'connection_id': conn_id})
    return {'statusCode': 200, 'body': 'processed'}
```

Video_tagging_lambda:

```
# -*- coding: utf-8 -*-
import os
import json
import time
import boto3
from botocore.exceptions import ClientError
from ultralytics import YOLO
import supervision as sv
import cv2 as cv

REGION         = os.getenv("AWS_REGION")
VIDEO_BUCKET   = os.getenv("VIDEO_S3")
THUMB_BUCKET   = os.getenv("THUMBNAILS_S3")
METADATA_TABLE = os.getenv("METADATA_TABLE")
MODEL_PATH     = os.getenv("MODEL_PATH")

s3_client  = boto3.client("s3", region_name=REGION)
ddb_client = boto3.client("dynamodb", region_name=REGION)

_model = None
def get_model():
    global _model
    if _model is None:
        if not MODEL_PATH:
            raise RuntimeError("MODEL_PATH env is required")
        _model = YOLO(MODEL_PATH)
    return _model

def video_predict_unique_counts(video_path: str, confidence: float = 0.5) -> dict:
    """Track unique objects across frames and count distinct IDs per class."""
    video_info = sv.VideoInfo.from_video_path(video_path=video_path)
    fps = int(video_info.fps)
    class_dict = get_model().names

    cap = cv.VideoCapture(video_path)
    if not cap.isOpened():
        raise RuntimeError(f"cannot open video: {video_path}")

    model   = get_model()
    tracker = sv.ByteTrack(frame_rate=fps)
    unique_per_species = {}

    while True:
        ret, frame = cap.read()
        if not ret:
            break
        result     = model(frame)[0]
        detections = sv.Detections.from_ultralytics(result)
        if detections.class_id is None:
            continue
        mask       = detections.confidence > confidence
        detections = detections[mask]
        # è¿½è¸ª
        detections = tracker.update_with_detections(detections=detections)
        if detections.tracker_id is None:
            continue
        for trk_id, cls_id in zip(detections.tracker_id.tolist(), detections.class_id.tolist()):
            species = class_dict[int(cls_id)]
            unique_per_species.setdefault(species, set()).add(int(trk_id))

    cap.release()
    return {species: len(ids) for species, ids in unique_per_species.items()}

def _parse_event(event: dict):
    if "Records" in event and event["Records"] and "s3" in event["Records"][0]:
        s3rec  = event["Records"][0]["s3"]
        bucket = s3rec["bucket"]["name"]
        key    = s3rec["object"]["key"]
    else:
        bucket = event.get("bucket")
        key    = event.get("key")
        if not (bucket and key):
            return None, None, None, None

    base = os.path.basename(key)
    file_id, ext = os.path.splitext(base)
    return bucket, key, file_id, (ext.lstrip(".") or "mp4")

def handler(event, context):
    print(f"[DEBUG] Event: {json.dumps(event)}")

    bucket, key, file_id, ext = _parse_event(event)
    if not (bucket and key and file_id):
        return {"statusCode": 400, "body": json.dumps({"error":"Missing bucket/key/file_id"})}

    # ä»…å¤„ç† video/ å‰ç¼€
    if not key.startswith("video/"):
        print(f"[INFO] non-video prefix, ignore: {key}")
        return {"statusCode": 200, "body": json.dumps({"message": "Ignored non-video object"})}

    tmp_video_path = f"/tmp/{file_id}.{ext}"

    # S3 ä¸‹è½½
    try:
        s3_client.download_file(bucket, key, tmp_video_path)
        print(f"[INFO] S3 downloaded: s3://{bucket}/{key} -> {tmp_video_path}")
    except ClientError as e:
        print(f"[ERROR] S3 download failed: {e}")
        return {"statusCode": 500, "body": json.dumps({"error": "S3 download failed"})}

    # æ¨ç†
    try:
        counts = video_predict_unique_counts(tmp_video_path, confidence=0.5)
        print(f"[INFO] model counts={counts}")
    except Exception as e:
        print(f"[ERROR] model run failed: {e}")
        counts = {}

    s3_url = f"https://{bucket}.s3.amazonaws.com/{key}"

    # å°è¯•è¡¥å……ç¼©ç•¥å›¾ URLï¼ˆè‹¥ Thumbnail Lambda å·²ç”Ÿæˆï¼‰
    thumb_key = f"thumbnail/{file_id}.jpg"
    try:
        s3_client.head_object(Bucket=THUMB_BUCKET, Key=thumb_key)
        thumbnail_url = f"https://{THUMB_BUCKET}.s3.amazonaws.com/{thumb_key}"
    except ClientError:
        thumbnail_url = ""

    now_iso  = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    tags_map = { sp: {"N": str(cnt)} for sp, cnt in counts.items() }

    # ç»„ç»‡æ›´æ–°è¡¨è¾¾å¼
    update_parts = ["file_type = :ft", "s3_url = :s", "tags = :tg", "upload_timestamp = :u"]
    expr_attr_values = {
        ":ft": {"S": "video"},
        ":s":  {"S": s3_url},
        ":tg": {"M": tags_map},
        ":u":  {"S": now_iso}
    }
    if thumbnail_url:
        update_parts.append("thumbnail_url = :t")
        expr_attr_values[":t"] = {"S": thumbnail_url}

    update_expression = "SET " + ", ".join(update_parts)

    # æ›´æ–° DynamoDB
    try:
        ddb_client.update_item(
            TableName=METADATA_TABLE,
            Key={"file_id": {"S": file_id}},
            UpdateExpression=update_expression,
            ExpressionAttributeValues=expr_attr_values
        )
        print(f"[INFO] updated DynamoDB: file_id={file_id}, tags={counts}")
    except ClientError as e:
        print(f"[ERROR] update DynamoDB failed: {e}")
        raise
    finally:
        try: os.remove(tmp_video_path)
        except: pass

    return {"statusCode": 200, "body": json.dumps({"message": f"Processed video {file_id}", "tags": counts})}

```



Image_tagging_lambda

```
# -*- coding: utf-8 -*-
import os
import json
import time
import boto3
from botocore.exceptions import ClientError
from ultralytics import YOLO
import supervision as sv
import cv2 as cv

REGION         = os.getenv("AWS_REGION")
IMAGES_BUCKET  = os.getenv("IMAGES_S3")        # æœªç›´æ¥ä½¿ç”¨ï¼Œåªä½œå ä½/æ ¡éªŒ
METADATA_TABLE = os.getenv("METADATA_TABLE")
MODEL_PATH     = os.getenv("MODEL_PATH")

s3_client  = boto3.client("s3", region_name=REGION)
ddb_client = boto3.client("dynamodb", region_name=REGION)

_model = None
def get_model():
    global _model
    if _model is None:
        if not MODEL_PATH:
            raise RuntimeError("MODEL_PATH env is required")
        _model = YOLO(MODEL_PATH)
    return _model

def get_detect_counts(image_path: str, confidence: float = 0.5) -> dict:
    """Run YOLO on image and return {class_name: count}."""
    model = get_model()
    class_dict = model.names

    img = cv.imread(image_path)
    if img is None:
        raise RuntimeError(f"cannot read image: {image_path}")

    result = model(img)[0]
    detections = sv.Detections.from_ultralytics(result)
    if detections.class_id is not None:
        mask = detections.confidence > confidence
        detections = detections[mask]
    else:
        detections = sv.Detections.empty()

    counts = {}
    if detections.class_id is not None:
        for cls_id in detections.class_id.tolist():
            species = class_dict[int(cls_id)]
            counts[species] = counts.get(species, 0) + 1

    return counts

def _parse_event(event: dict):
    """Return (bucket, key, file_id, ext) from S3 event or custom payload."""
    if "Records" in event and event["Records"] and "s3" in event["Records"][0]:
        s3rec  = event["Records"][0]["s3"]
        bucket = s3rec["bucket"]["name"]
        key    = s3rec["object"]["key"]
    else:
        bucket = event.get("bucket")
        key    = event.get("key")
        if not (bucket and key):
            return None, None, None, None

    base = os.path.basename(key)
    file_id, ext = os.path.splitext(base)
    return bucket, key, file_id, (ext.lstrip(".") or "jpg")

def handler(event, context):
    print(f"[DEBUG] Event: {json.dumps(event)}")

    bucket, key, file_id, ext = _parse_event(event)
    if not (bucket and key and file_id):
        return {"statusCode": 400, "body": json.dumps({"error": "Missing bucket/key or unsupported event"})}

    # ä»…å¤„ç† image/ å‰ç¼€
    if not key.startswith("image/"):
        print(f"[INFO] non-image prefix, ignore: {key}")
        return {"statusCode": 200, "body": json.dumps({"message": "Ignored non-image object"})}

    tmp_path = f"/tmp/{file_id}.{ext}"

    # ä» S3 ä¸‹è½½åŸå›¾
    try:
        s3_client.download_file(bucket, key, tmp_path)
        print(f"[INFO] S3 downloaded: s3://{bucket}/{key} -> {tmp_path}")
    except ClientError as e:
        print(f"[ERROR] S3 download fail: {e}")
        return {"statusCode": 500, "body": json.dumps({"error": "S3 download failed"})}

    # æ¨ç†
    try:
        counts = get_detect_counts(tmp_path, confidence=0.5)
        print(f"[INFO] inference counts: {counts}")
    except Exception as e:
        print(f"[ERROR] model run failed: {e}")
        counts = {}

    s3_url  = f"https://{bucket}.s3.amazonaws.com/{key}"
    now_iso = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime())
    tags_map = { sp: {"N": str(cnt)} for sp, cnt in counts.items() }

    # æ›´æ–° DynamoDB
    try:
        ddb_client.update_item(
            TableName=METADATA_TABLE,
            Key={"file_id": {"S": file_id}},
            UpdateExpression="SET file_type = :ft, s3_url = :s, tags = :tg, upload_timestamp = :u",
            ExpressionAttributeValues={
                ":ft": {"S": "image"},
                ":s":  {"S": s3_url},
                ":tg": {"M": tags_map},
                ":u":  {"S": now_iso}
            }
        )
        print(f"[INFO] DynamoDB updated: file_id={file_id}, file_type=image")
    except ClientError as e:
        print(f"[ERROR] DynamoDB update failed: {e}")
        raise
    finally:
        try: os.remove(tmp_path)
        except: pass

    return {"statusCode": 200, "body": json.dumps({"message": f"Processed image {file_id}", "tags": counts})}

```



Thumbnail_lambda

```
# -*- coding: utf-8 -*-
import os
import json
import time
import boto3
import cv2 as cv
from botocore.exceptions import ClientError

REGION         = os.getenv("AWS_REGION")
IMAGES_BUCKET  = os.getenv("IMAGES_S3")
VIDEO_BUCKET   = os.getenv("VIDEO_S3")
THUMB_BUCKET   = os.getenv("THUMBNAILS_S3")
METADATA_TABLE = os.getenv("METADATA_TABLE")

s3_client  = boto3.client("s3", region_name=REGION)
ddb_client = boto3.client("dynamodb", region_name=REGION)

def generate_image_thumbnail(source_path: str, dest_path: str, max_width: int = 200):
    img = cv.imread(source_path)
    if img is None:
        raise RuntimeError(f"Cannot read image: {source_path}")
    h, w = img.shape[:2]
    if w <= max_width:
        cv.imwrite(dest_path, img, [int(cv.IMWRITE_JPEG_QUALITY), 85])
        return
    scale = max_width / float(w)
    new_dim = (max_width, int(h * scale))
    resized = cv.resize(img, new_dim, interpolation=cv.INTER_AREA)
    cv.imwrite(dest_path, resized, [int(cv.IMWRITE_JPEG_QUALITY), 85])

def generate_video_thumbnail(source_path: str, dest_path: str, max_width: int = 200):
    cap = cv.VideoCapture(source_path)
    if not cap.isOpened():
        raise RuntimeError(f"Unable to open video: {source_path}")
    ret, frame = cap.read()
    cap.release()
    if not ret or frame is None:
        raise RuntimeError(f"Cannot read the first frame: {source_path}")
    h, w = frame.shape[:2]
    if w <= max_width:
        cv.imwrite(dest_path, frame, [int(cv.IMWRITE_JPEG_QUALITY), 85])
        return
    scale = max_width / float(w)
    new_dim = (max_width, int(h * scale))
    resized = cv.resize(frame, new_dim, interpolation=cv.INTER_AREA)
    cv.imwrite(dest_path, resized, [int(cv.IMWRITE_JPEG_QUALITY), 85])

def _parse_event(event: dict):
    if "Records" in event and event["Records"] and "s3" in event["Records"][0]:
        s3rec  = event["Records"][0]["s3"]
        bucket = s3rec["bucket"]["name"]
        key    = s3rec["object"]["key"]
        base   = os.path.basename(key)
        file_id, ext = os.path.splitext(base)
        return bucket, key, file_id, ext.lstrip(".")
    else:
        bucket  = event.get("bucket")
        key     = event.get("key")
        file_id = event.get("file_id")
        if not (bucket and key and file_id):
            return None, None, None, None
        _, ext = os.path.splitext(key)
        return bucket, key, file_id, ext.lstrip(".")

def handler(event, context):
    print(f"[DEBUG] Event: {json.dumps(event)}")
    bucket, key, file_id, ext = _parse_event(event)
    if not (bucket and key and file_id):
        return {"statusCode": 400, "body": json.dumps({"error": "Invalid event payload"})}

    # åªå¤„ç† image/ æˆ– video/
    prefix = key.split("/", 1)[0] if "/" in key else ""
    if prefix not in ("image", "video"):
        print(f"[INFO] ignore non image/video prefix: {key}")
        return {"statusCode": 200, "body": json.dumps({"message": "Ignored prefix"})}

    tmp_src   = f"/tmp/{file_id}.{ext or 'bin'}"
    tmp_thumb = f"/tmp/{file_id}.jpg"

    # ä¸‹è½½æºæ–‡ä»¶
    try:
        s3_client.download_file(bucket, key, tmp_src)
    except ClientError as e:
        print(f"[ERROR] S3 download failed: {e}")
        raise

    # ç”Ÿæˆç¼©ç•¥å›¾
    try:
        if prefix == "image":
            generate_image_thumbnail(tmp_src, tmp_thumb)
        else:
            generate_video_thumbnail(tmp_src, tmp_thumb)
    except Exception as e:
        print(f"[ERROR] thumbnail generation failed: {e}")
        try: os.remove(tmp_src)
        except: pass
        raise

    # ä¸Šä¼ ç¼©ç•¥å›¾åˆ° THUMBNAILS_S3/thumbnail/{file_id}.jpg
    thumb_key = f"thumbnail/{file_id}.jpg"
    try:
        s3_client.upload_file(tmp_thumb, THUMB_BUCKET, thumb_key, ExtraArgs={"ContentType": "image/jpeg"})
    except ClientError as e:
        print(f"[ERROR] upload thumbnail failed: {e}")
        try: os.remove(tmp_src)
        except: pass
        try: os.remove(tmp_thumb)
        except: pass
        raise

    thumbnail_url = f"https://{THUMB_BUCKET}.s3.amazonaws.com/{thumb_key}"

    # æ›´æ–° DynamoDB
    try:
        ddb_client.update_item(
            TableName=METADATA_TABLE,
            Key={"file_id": {"S": file_id}},
            UpdateExpression="SET thumbnail_url = :t",
            ExpressionAttributeValues={":t": {"S": thumbnail_url}}
        )
        print(f"[INFO] thumbnail_url updated: {file_id} -> {thumbnail_url}")
    except ClientError as e:
        print(f"[ERROR] DynamoDB update failed: {e}")
        # ä¸æŠ›å‡ºï¼Œä»¥å…é‡å¤è§¦å‘ï¼›å¯æŒ‰éœ€æŠ›å‡º
        pass

    # æ¸…ç†
    for p in (tmp_src, tmp_thumb):
        try: os.remove(p)
        except: pass

    return {
        "statusCode": 200,
        "body": json.dumps({"message": f"Thumbnail generated for {file_id}", "thumbnail_url": thumbnail_url})
    }

```




## 2. API Gateway ç«¯ç‚¹ â†’ Lambda å…³è”

ä»¥ä¸‹åˆ—å‡ºä½ çš„ REST + WebSocket çš„ç«¯ç‚¹åŠå¯¹åº” Lambdaï¼š

| ç«¯ç‚¹                                    | ç±»å‹         | å…³è” Lambda             |
| --------------------------------------- | ------------ | ----------------------- |
| `POST /upload-file`                     | REST         | UploadFileLambda        |
| WebSocket `$connect` è·¯ç”±               | WebSocket    | ConnectHandlerLambda    |
| WebSocket `$disconnect` è·¯ç”±            | WebSocket    | DisconnectHandlerLambda |
| DynamoDB Streamï¼ˆ`METADATA_TABLE`ï¼‰è§¦å‘ | AWS äº‹ä»¶è§¦å‘ | MetaDbUpdateLambda      |





# å‰åç«¯æ•°æ®äº¤æµè¿‡ç¨‹ï¼š

## ğŸš€ æ•´ä½“æµç¨‹ï¼ˆé«˜å±‚ï¼‰

1. ç”¨æˆ·åœ¨å‰ç«¯ç½‘é¡µä¸­ç™»å½•ï¼Œè·å– JWT tokenã€‚
2. å‰ç«¯é€šè¿‡ REST API ä¸Šä¼ è¯·æ±‚ï¼šè¯·æ±‚é¢„ç­¾å URLï¼Œåå°ç”Ÿæˆ metadata æ¡ç›®ã€è¿”å› presign URLã€‚
3. å‰ç«¯ä½¿ç”¨è¿”å›çš„ presign URL ä¸Šä¼ æ–‡ä»¶åˆ° Amazon S3ï¼ˆæ ¹æ®ç±»å‹é€‰æ‹©æ¡¶ + keyï¼‰ã€‚
4. å‰ç«¯å»ºç«‹ WebSocket è¿æ¥åˆ° Amazon API Gateway WebSocket APIï¼Œå¹¶å°† token + file_id å‘é€ç”¨äºè¿æ¥æˆæƒã€‚
5. S3 ä¸Šä¼ å®Œæˆåè§¦å‘äº‹ä»¶ï¼Œå¯åŠ¨ç¼©ç•¥å›¾ Lambdaï¼æ ‡ç­¾è¯†åˆ« Lambda ç­‰ï¼Œæ›´æ–° Amazon DynamoDB è¡¨ METADATA_TABLEï¼ˆç¼©ç•¥å›¾ URLã€tags ç­‰ï¼‰ã€‚
6. DynamoDB Stream æ£€æµ‹åˆ°è¡¨æ¡ç›®å˜åŒ–ï¼Œè§¦å‘ MetaDbUpdateLambdaï¼ŒæŸ¥è¯¢ CONNECTION_TABLE å–å¾—æ´»è·ƒ WebSocket è¿æ¥ï¼Œå‘å‰ç«¯é€šè¿‡ API Gateway ç®¡ç†ç«¯ç‚¹æ¨é€æ¶ˆæ¯ã€‚
7. å‰ç«¯ WebSocket æ”¶åˆ°æ›´æ–°æ¶ˆæ¯åï¼Œæ›´æ–° UIï¼ˆä¾‹å¦‚æ˜¾ç¤ºç¼©ç•¥å›¾ã€è¯†åˆ«æ ‡ç­¾ï¼‰ã€‚ç”¨æˆ·ä¹Ÿå¯è°ƒç”¨ REST API æ‹‰å–æœ€æ–° metadata ä½œä¸ºè¡¥å¿ã€‚
8. è‹¥å‰ç«¯æ–­å¼€è¿æ¥ï¼å…³é—­é¡µé¢ï¼ŒWebSocket è§¦å‘ `$disconnect` è·¯ç”±ï¼Œåå° åˆ é™¤ CONNECTION_TABLE ä¸­å¯¹åº”è¿æ¥ã€‚

------

## ğŸ” è¯¦ç»†æ­¥éª¤æ‹†è§£

### æ­¥éª¤ Aï¼šç”¨æˆ·ç™»å½•

- ç”¨æˆ·åœ¨å‰ç«¯ç½‘é¡µé€šè¿‡ Amazon Cognitoï¼ˆæˆ–è‡ªå»ºè®¤è¯ï¼‰ç™»å½•ï¼Œå¾—åˆ° JWT tokenï¼Œå…¶ä¸­åŒ…å« `user_id`ï¼ˆæˆ– `sub`ï¼‰ç­‰ã€‚
- å‰ç«¯ä¿å­˜è¿™ä¸ª tokenï¼Œç”¨äºåç»­ REST è°ƒç”¨ & WebSocket å»ºç«‹ã€‚

### æ­¥éª¤ Bï¼šä¸Šä¼ è¯·æ±‚

- å‰ç«¯è°ƒç”¨ REST APIï¼š`POST /upload-file`ï¼Œè¯·æ±‚ä½“ä¾‹å¦‚ï¼š

  ```
  {
    "token": "<JWT>",
    "filename": "example.jpg",
    "content_type": "image/jpeg"
  }
  ```

- åç«¯ä¸Šä¼  Lambdaï¼ˆUploadFileLambdaï¼‰ï¼š

  - éªŒè¯ tokenï¼ˆå‘è¡Œè€…ã€å—ä¼—ã€è¿‡æœŸã€ç­¾åç­‰ï¼‰ï¼Œä»ä¸­å–å‡º `user_id`ã€‚

  - ç”Ÿæˆå”¯ä¸€ `file_id`ã€‚

  - æ ¹æ® `content_type` åˆ¤å®š `file_type`ï¼šå¦‚ â€œimageâ€ / â€œvideoâ€ / â€œaudioâ€ã€‚

  - æ„é€  S3 keyï¼Œæ¯”å¦‚ `image/{user_id}_{file_id}.jpg`ã€‚

  - åœ¨ METADATA_TABLE æ’å…¥æ¡ç›®ï¼š

    ```
    {
      "file_id": "...",
      "user_id": "...",
      "s3_url": null,
      "thumbnail_url": null,
      "file_type": "image",
      "tags": {},
      "upload_timestamp": "...",
      "additional_metadata": {}
    }
    ```

  - ç”Ÿæˆ S3 presigned PUT URLï¼ˆç›®æ ‡æ¡¶ä¸º IMAGES_S3ï¼VIDEO_S3ï¼AUDIO_S3ï¼Œkey å¦‚ä¸Šï¼‰ã€‚

  - è¿”å›ç»™å‰ç«¯ï¼š

    ```
    {
      "file_id": "...",
      "presign_url": "...",
      "s3_key": "image/user42_abcd1234.jpg"
    }
    ```

### æ­¥éª¤ Cï¼šæ–‡ä»¶ä¸Šä¼  + WebSocket å»ºç«‹

- å‰ç«¯ä½¿ç”¨ `presign_url` ä¸Šä¼ æ–‡ä»¶å†…å®¹è‡³ S3ã€‚

- åŒæ—¶ï¼Œå‰ç«¯ä½¿ç”¨ WebSocket è¿æ¥è‡³ API Gateway WebSocket APIï¼ŒURL å¦‚ï¼š

  ```
  wss://{api-id}.execute-api.{region}.amazonaws.com/{stage}?token=<JWT>&file_id=<file_id>
  ```

- WebSocket çš„ `$connect` è·¯ç”±è¢«è§¦å‘ï¼Œåå° ConnectHandlerLambda éªŒè¯ tokenã€åœ¨ CONNECTION_TABLE å†™å…¥ä¸€æ¡è®°å½•ï¼š

  ```
  {
    "connection_id": "<connectionId>",
    "user_id": "<user_id>",
    "connected_at": "...",
    "last_seen": "..."
  }
  ```

### æ­¥éª¤ Dï¼šS3 ä¸Šä¼ è§¦å‘å¤„ç†

- æ–‡ä»¶ä¸Šä¼ æˆåŠŸåï¼ŒS3 å¯¹åº”æ¡¶ï¼ˆå¦‚ IMAGES_S3 æˆ– VIDEO_S3ï¼‰è§¦å‘äº‹ä»¶ï¼ˆé€šè¿‡ S3 Event æˆ– EventBridgeï¼‰ã€‚
- æ ¹æ® file_typeï¼š
  - å¦‚æœæ˜¯ image æˆ– videoï¼šThumbnailLambda ç”Ÿæˆç¼©ç•¥å›¾ â†’ ä¸Šä¼ è‡³ THUMBNAILS_S3 â†’ æ›´æ–° METADATA_TABLE ä¸­è¯¥æ¡ç›®çš„ `thumbnail_url`ã€‚
  - å¦‚æœæ˜¯ imageï¼šImageTaggingLambda æ‰§è¡Œè¯†åˆ« â†’ æ›´æ–° `tags` å­—æ®µã€‚
  - å¦‚æœæ˜¯ videoï¼šVideoTaggingLambda è¯†åˆ«ï¼å¸§åˆ†æ â†’ å†™å…¥ `tags` + `additional_metadata`ã€‚
  - å¦‚æœæ˜¯ audioï¼šAudioTaggingLambdaï¼ˆè‹¥æœ‰ï¼‰å†™å…¥å¯¹åº” metadataã€‚
- æ¯æ¬¡å¯¹ METADATA_TABLE çš„æ›´æ–°éƒ½ä¼šè§¦å‘ DynamoDB Streamsã€‚

### æ­¥éª¤ Eï¼šDynamoDB Streams â†’ MetaDbUpdateLambda

- METADATA_TABLE å¯ç”¨ Streamsã€‚ä»»ä½• `NewImage` æ›´æ–°äº§ç”Ÿè§¦å‘ã€‚

- MetaDbUpdateLambda è¢«è§¦å‘ï¼Œè¯»å– `NewImage` ä¸­çš„å­—æ®µï¼š`file_id`ã€`user_id`ã€`thumbnail_url`ã€`tags`ã€`file_type`ã€`s3_url`ã€`upload_timestamp`ã€‚

- å®ƒæŸ¥è¯¢ CONNECTION_TABLEï¼Œæ‰¾å‡º `user_id` å¯¹åº”çš„æ‰€æœ‰ `connection_id`ã€‚

- å¯¹æ¯ä¸ªè¿æ¥ï¼Œç”¨ API Gateway ç®¡ç†ç«¯ç‚¹ï¼ˆ`apigatewaymanagementapi.PostToConnection`ï¼‰å‘é€æ¶ˆæ¯ï¼š

  ```
  {
    "type": "FILE_UPDATE",
    "file_id": "...",
    "file_type": "...",
    "thumbnail_url": "https://â€¦",
    "tags": { â€¦ },
    "upload_timestamp": "..."
  }
  ```

- è‹¥ `PostToConnection` è¿”å›é”™è¯¯ï¼ˆå¦‚ 410 Goneï¼‰ï¼Œåˆ é™¤å¯¹åº” CONNECTION_TABLE çš„è¿æ¥è®°å½•ã€‚

### æ­¥éª¤ Fï¼šå‰ç«¯ WebSocket æ¥æ”¶æ¶ˆæ¯ + UI æ›´æ–°

- å‰ç«¯çš„ WebSocket `onmessage` äº‹ä»¶è§¦å‘ï¼Œæ”¶åˆ° payloadã€‚
- å¦‚æœ `thumbnail_url` å‡ºç°ä½† `tags` ä»ç©º â†’ å‰ç«¯æ›´æ–° UI æ˜¾ç¤ºç¼©ç•¥å›¾ã€‚
- å½“ `tags` å‡ºç°å â†’ å‰ç«¯æ˜¾ç¤ºè¯†åˆ«ç»“æœã€‚
- å‰ç«¯å¯ä»¥æä¾›â€œåˆ·æ–°â€æŒ‰é’®æˆ–é¡µé¢é‡è½½ â†’ è°ƒç”¨ REST API `GET /metadata/{file_id}` ä»åç«¯æ‹‰å–æœ€æ–° metadata è¡¨å†…å®¹ä½œä¸ºè¡¥å¿ã€‚

### æ­¥éª¤ Gï¼šè¿æ¥æ–­å¼€ + æ¸…ç†

- å¦‚æœç”¨æˆ·å…³é—­ç½‘é¡µï¼æ–­å¼€ WebSocketï¼ŒAPI Gateway è§¦å‘ `$disconnect` è·¯ç”± â†’ DisconnectHandlerLambda åˆ é™¤ CONNECTION_TABLE ä¸­è®°å½•ã€‚
- åœ¨æ¨é€é˜¶æ®µå¦‚æœå‘ç°è¿æ¥å¤±æ•ˆï¼Œä¹Ÿä¼šåœ¨ Lambda ä¸­åˆ é™¤ã€‚



